#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    IRsensor1,      sensorAnalog)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  LED1,           sensorDigitalOut)
#pragma config(Sensor, dgtl4,  LED2,           sensorDigitalOut)
#pragma config(Sensor, dgtl6,  LED3,           sensorDigitalOut)
#pragma config(Sensor, dgtl8,  Sonar,          sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  motor1,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motor2,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int light_threshold = 40;

bool IR_detected()
{
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[IRsensor1];
	bool returnValue;

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		}	else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	// Check if light level difference over threshold.
	if ( diffLevelIR1 > light_threshold ) {
		returnValue = true;
		} else {
		returnValue = false;
	}

	return(returnValue);
}


task main()
{
enum T_distancecheck_state {
		TOO_CLOSE = 0,
		TOO_FAR,
		JUST_RIGHT,
		NO_IR
	};

SensorValue[LED1] = SensorValue[LED2] = SensorValue[LED3]= 0;
T_distancecheck_state distancecheck_state = NO_IR;

while(true){
	switch(distancecheck_state){
	case TOO_CLOSE:

	SensorValue[LED1] = 1;
	SensorValue[LED2] = SensorValue[LED3] = 0;

		if(SensorValue[Sonar] > 20 && IR_detected()){
			distancecheck_state = TOO_FAR;
		}//End if

		if(SensorValue[Sonar] <= 20 && SensorValue[Sonar] >= 14 && IR_detected()){
			distancecheck_state = JUST_RIGHT;
		}//End if

		if(!IR_detected()){
			distancecheck_state = NO_IR;
		}//End if

	break;

	case TOO_FAR:

	SensorValue[LED2] = 1;
	SensorValue[LED1] = SensorValue[LED3] = 0;

		if(SensorValue[Sonar] < 14 && IR_detected()){
		distancecheck_state = TOO_CLOSE;
	}//End if

		if(SensorValue[Sonar] <= 20 && SensorValue[Sonar] >= 14 && IR_detected()){
		distancecheck_state = JUST_RIGHT;
	}//End if

		if(!IR_detected()){
		distancecheck_state = NO_IR;
	}//End if

	break;

	case JUST_RIGHT:

	SensorValue[LED3] = 1;
	SensorValue[LED1] = SensorValue[LED2] = 0;

		if(SensorValue[Sonar] < 14 && IR_detected()){
		distancecheck_state = TOO_CLOSE;
	}//End if

		if(SensorValue[Sonar] > 20 && IR_detected()){
		distancecheck_state = TOO_FAR;
	}//End if

		if(!IR_detected()){
		distancecheck_state = NO_IR;
	}//End if

	break;

	case NO_IR:

	SensorValue[LED1] = SensorValue[LED2] = SensorValue[LED3]= 0;

		if(SensorValue[Sonar] < 14 && IR_detected()){
		distancecheck_state = TOO_CLOSE;
	}//End if

		if(SensorValue[Sonar] > 20 && IR_detected()){
		distancecheck_state = TOO_FAR;
	}//End if

		if(SensorValue[Sonar] <= 20 && SensorValue[Sonar] >= 14 && IR_detected()){
		distancecheck_state = JUST_RIGHT;
	}//End if

	default: //Should never happen


	}//End switch
}//End while


}
