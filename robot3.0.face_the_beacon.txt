#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    IRsensor1,      sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, I2C_1,  motor1,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motor2,        tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool button1_pushed;
const int light_threshold = 75;
bool IR_detected;

bool IR_test()
{
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[IRsensor1];
	bool returnValue;

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		}	else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	// Check if light level difference over threshold.
	if ( diffLevelIR1 > light_threshold ) {
		returnValue = true;
		} else {
		returnValue = false;
	}

	return(returnValue);
}



void monitorInput(){

	if(SensorValue(button1)) {
		button1_pushed = true;
	} //End if
	IR_detected = IR_test();

}//End monitorInput

task main()
{
enum T_faceobject_state {
		MOTOR_STOP = 0,
		ROBOT_TURNS
	};
	T_faceobject_state faceobject_state = MOTOR_STOP;
	button1_pushed = false;

	while(true){
monitorInput();

switch(faceobject_state){

case MOTOR_STOP:

	motor [motor1] = 0;
	motor [motor2] = 0;
	//Robot stops

	if (button1_pushed){
			faceobject_state = ROBOT_TURNS;
			button1_pushed = false;
	} //End if


break; //End MOTOR_STOP

case ROBOT_TURNS:
	motor [motor1] = 30;
	motor [motor2] = -30;
	//Robot turns

	if (IR_detected){
		faceobject_state = MOTOR_STOP;
		IR_detected = false;
	}//End if

	if (button1_pushed) {
		faceobject_state = MOTOR_STOP;
		button1_pushed = false;
	}//End if

break; //End ROBOT_TURNS

default: //should never happen

}//End switch
}//End while
}//End main
